/*--------------------------------------------------------------------------#
#  Jenkins running on remote EC2 AWS instance, remote webserver too         #
#  Need to install ssh plugins                                              #
#  Edit jenkins configuration to add remote server and ssh key              #
#  Its better to set "/" directory and define declaratively                 #
#  Create new pipeline, choose SCM using https                              #
#  Configure 1 slave (ubuntu), add ssh keys                                 #
#  Plugins "Docker Pipeline", "Amazon ECR", "Parameterized Trigger plugin"  #
#  Create DockerHub token, add creds to Jenkins                             #
#                                                                           #
#  Select "Script path" in git repo jenkins/docker_php_deploy/Jenkinsfile   #
#                                                                           #
#  Last update:        02.06.2023                                           #
#--------------------------------------------------------------------------*/
pipeline {
    agent { label 'slave-1' }
        parameters {
            choice(name: 'VERSION', choices: ['1', '2'], description: 'Version example')
            booleanParam(name: 'RemoteDeploy', defaultValue: false, description: 'Deploy stage or not')
        }
    environment {
        CI_IMAGE_NAME = 'web_container'
        CI_CONTAINER_NAME = 'test_container'
        CONTAINER_EXTERNAL_PORT = '8080'

        CD_IMAGE_REPO_USER = 'wood8'
        CD_IMAGE_REPO_NAME = 'jenkins-webserver'
    }

    options {
        skipDefaultCheckout()
        timestamps()
    }

    stages {
        stage('Delete workspace before build starts') {
            steps {
                echo 'Deleting workspace dir'
                deleteDir()
            }
        }

        // Без этого степа создаются директории но не скачиваются файлы
        stage('Checkout git') {
            steps {
                script {
                    git(
                        url: 'https://github.com/gitwood8/jenkins-deploy-webapp.git',
                        branch: 'main'
                    )
                    env.GIT_COMMIT = sh(returnStdout: true, script: 'git rev-parse --short=5 HEAD').trim()
                }
            }
        }

        stage('Build image') {
            steps {
                script {
                    dir('jenkins/docker_php_deploy/docker/') {
                        docker.build("${CD_IMAGE_REPO_USER}/${CD_IMAGE_REPO_NAME}:${env.GIT_COMMIT}")
                    }
                }
            }
        }

        stage('Run container test') {
            steps {
                script {
                    def dockerImage = docker.image("${CD_IMAGE_REPO_USER}/${CD_IMAGE_REPO_NAME}:${env.GIT_COMMIT}")
                    dockerImage.run("-d --rm --name ${env.CI_CONTAINER_NAME} -p ${env.CONTAINER_EXTERNAL_PORT}:80")
                    sleep 20
                    sh "docker inspect --format='{{json .State.Health}}' \$(docker ps -q) | grep '\"Status\":\"healthy\"'"
                    //docker.stop() - not permited 
                    sh 'docker ps -qa | xargs docker stop'
                }
            }
        }

// docker url: ~$docker info
        stage('Push to DockerHub') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'dockerhub-cred-jenkins-wood8', url: 'https://index.docker.io/v1/') {
                        docker.image("${CD_IMAGE_REPO_USER}/${CD_IMAGE_REPO_NAME}:${env.GIT_COMMIT}").push()
                    }
                }
            }
        }

        stage('Stop container and clean area') {
            steps {
                script {
                    sh 'docker images -qa | xargs docker rmi 2>/dev/null --force || true'
                    sh 'if [ \$(docker images -qa | wc -l) = "0" ]; then echo "Success"; else echo "Vse ploho"; fi'
                }
            }
        }

        // Определять дополнительные переменные нужно для конкретного стэйджа:
        stage('Run container on remote server') {
            environment {
                FULL_IMAGE_NAME = "${CD_IMAGE_REPO_USER}/${CD_IMAGE_REPO_NAME}:${env.GIT_COMMIT}"
            }
            steps {
                script {
                    println("This is testtttttttttttttttttttttttt")
//                    echo '------Run------' тут можно доп шаги добавить
                    sshPublisher(
                        publishers: [
                            sshPublisherDesc(
                                configName: 'aws-webserver',
                                transfers: [
                                    sshTransfer(
                                        execCommand: """
                                        docker pull ${FULL_IMAGE_NAME};
                                        docker run -d --rm --name ${CI_CONTAINER_NAME} -p ${CONTAINER_EXTERNAL_PORT}:80 ${FULL_IMAGE_NAME};
                                        sleep 20;
                                        echo ${FULL_IMAGE_NAME} >> ~/joooooooooooopa2.txt
                                        """
                                    ),
                                    sshTransfer(
                                        execCommand: 'docker ps >> ~/joooooooooooopa2.txt; docker images >> ~/joooooooooooopa2.txt'
                                    )
                                ]
                            )
                        ]
                    )
                }
            }
        }

// /*         stage('Test run container on remote server') {
//             steps {
//                 script {
//                     def remoteNode = getNodeByLabel('aws-webserver') // Replace 'your_remote_host' with the label of your remote host in Jenkins
//                     //def remoteDir = '/home/ec2-user/qwe/' // Replace with the directory where your Dockerfile is located on the remote server

//                     // Pull the Docker image from Docker Hub
//                     remoteNode.withGroovy {
//                         docker.image("${CD_IMAGE_REPO_USER}/${CD_IMAGE_REPO_NAME}:${env.GIT_COMMIT}").pull()
//                     }

//                     // Run the Docker container
//                     remoteNode.withGroovy {
//                         docker.image("${CD_IMAGE_REPO_USER}/${CD_IMAGE_REPO_NAME}:${env.GIT_COMMIT}").run("-d --rm --name ${env.CI_CONTAINER_NAME} -p ${env.CONTAINER_EXTERNAL_PORT}:80")
//                     }

//                     sleep 30

//                     // Stop and remove the Docker container
//                     remoteNode.withGroovy {
//                         docker.image("${CD_IMAGE_REPO_USER}/${CD_IMAGE_REPO_NAME}:${env.GIT_COMMIT}").stop()
//                     }
    }
}
